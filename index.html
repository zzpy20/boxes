<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ğŸ“¦ Storage Boxes Index</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex" />
  <style>
    :root { --bg:#f6f7f9; --card:#fff; --text:#111; --muted:#666; --line:#e6e8ee; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      margin: 0; padding: 16px; background: var(--bg); color: var(--text);
    }
    header { max-width: 980px; margin: 0 auto 14px auto; }
    h1 { margin: 0 0 8px 0; font-size: 22px; }
    .sub { color: var(--muted); font-size: 13px; margin: 0 0 14px 0; line-height: 1.4; }

    .toolbar {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }
    input[type="search"]{
      width: 100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      outline: none;
      font-size: 15px;
      background: #fff;
    }
    .counter {
      font-size: 13px; color: var(--muted);
      padding: 10px 12px; background: #fff;
      border: 1px solid var(--line); border-radius: 12px;
      white-space: nowrap;
    }

    .grid {
      max-width: 980px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 12px;
    }
    a.card {
      display: block;
      text-decoration: none;
      color: inherit;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,.06);
      transition: transform .05s ease, box-shadow .05s ease;
    }
    a.card:active { transform: scale(0.99); box-shadow: 0 1px 2px rgba(0,0,0,.10); }

    .thumb {
      width: 100%;
      aspect-ratio: 16 / 10;
      background: #f1f2f5;
      display: none;
      object-fit: cover;
    }
    .content { padding: 12px; }
    .title { font-weight: 800; letter-spacing: .3px; font-size: 16px; margin-bottom: 6px; }
    .note { color: var(--muted); font-size: 13px; line-height: 1.35; min-height: 34px; white-space: pre-wrap; }
    .tags { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 6px; }
    .tag {
      font-size: 12px;
      color: #334155;
      background: #eef2ff;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #e0e7ff;
    }

    .empty {
      max-width: 980px; margin: 18px auto 0 auto;
      color: var(--muted); font-size: 14px;
      padding: 12px 14px; background: #fff;
      border: 1px dashed var(--line); border-radius: 12px;
      display: none;
    }

    footer {
      max-width: 980px;
      margin: 18px auto 0 auto;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }
    code { background: #fff; padding: 2px 6px; border: 1px solid var(--line); border-radius: 8px; }
  </style>
</head>
<body>

<header>
  <h1>ğŸ“¦ Storage Boxes Index / ç®±å­æ€»ç´¢å¼•</h1>
  <p class="sub">
    æ•°æ®æºï¼š<code>boxes.csv</code>ï¼ˆä½ ç”¨ Excel ç¼–è¾‘å®ƒå³å¯ï¼‰ã€‚<br>
    æœç´¢æ”¯æŒï¼šç®±å·ï¼ˆ<code>01</code> / <code>BOX-01</code>ï¼‰ã€å¤‡æ³¨å…³é”®è¯ã€æ ‡ç­¾ã€‚<br>
    ç‚¹å‡»å¡ç‰‡ â†’ æ‰“å¼€ <code>/box-XX/</code> â†’ è‡ªåŠ¨è¯»å– CSV çš„ url å¹¶è·³è½¬ã€‚
  </p>

  <div class="toolbar">
    <input id="q" type="search" placeholder="æœç´¢ï¼šBOX-23 / cables / å†¬å­£ / kids â€¦" autocomplete="off" />
    <div class="counter" id="counter">Loadingâ€¦</div>
  </div>
</header>

<div class="grid" id="grid"></div>
<div class="empty" id="empty">æ²¡æœ‰åŒ¹é…ç»“æœã€‚è¯•è¯•è¾“å…¥ï¼š<code>07</code>ã€<code>kids</code>ã€<code>chargers</code>ã€<code>å†¬å­£</code>ã€‚</div>

<footer>
  GitHub Pages Â· zzpy20 Â· <span id="stamp"></span>
</footer>

<script>
  // Robust CSV parser (quoted fields, commas, newlines)
  function parseCsv(text) {
    const rows = [];
    let row = [];
    let field = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const next = text[i + 1];

      if (inQuotes) {
        if (c === '"' && next === '"') { field += '"'; i++; }
        else if (c === '"') { inQuotes = false; }
        else { field += c; }
      } else {
        if (c === '"') inQuotes = true;
        else if (c === ',') { row.push(field); field = ""; }
        else if (c === '\r') {}
        else if (c === '\n') {
          row.push(field); field = "";
          if (row.length > 1 || (row.length === 1 && row[0].trim() !== "")) rows.push(row);
          row = [];
        } else field += c;
      }
    }
    if (field.length || row.length) {
      row.push(field);
      if (row.length > 1 || (row.length === 1 && row[0].trim() !== "")) rows.push(row);
    }

    if (!rows.length) return { headers: [], data: [] };
    const headers = rows[0].map(h => (h || "").trim().toLowerCase());
    const data = rows.slice(1).map(cols => {
      const obj = {};
      headers.forEach((h, idx) => obj[h] = (cols[idx] ?? "").trim());
      return obj;
    });
    return { headers, data };
  }

  const grid = document.getElementById("grid");
  const q = document.getElementById("q");
  const counter = document.getElementById("counter");
  const empty = document.getElementById("empty");
  document.getElementById("stamp").textContent = new Date().toISOString().slice(0,10);

  function pad2(n){ return String(n).padStart(2, "0"); }
  function normalize(s){ return (s || "").toString().trim().toLowerCase(); }

  function splitTags(s){
    // tags column can be "a b c" or "a; b; c" or "a, b"
    const raw = (s || "").trim();
    if (!raw) return [];
    return raw
      .split(/[;,]/g)
      .flatMap(part => part.split(/\s+/g))
      .map(t => t.trim())
      .filter(Boolean);
  }

  function makeCard(box){
    const a = document.createElement("a");
    a.className = "card";
    a.href = `box-${box.id}/`;

    const img = document.createElement("img");
    img.className = "thumb";
    img.alt = `BOX-${box.id} preview`;
    if (box.preview) {
      img.src = box.preview;
      img.style.display = "block";
      img.onerror = () => { img.style.display = "none"; };
    }

    const c = document.createElement("div");
    c.className = "content";

    const t = document.createElement("div");
    t.className = "title";
    t.textContent = `BOX-${box.id}`;

    const note = document.createElement("div");
    note.className = "note";
    note.textContent = box.note || "";

    const tagsWrap = document.createElement("div");
    tagsWrap.className = "tags";
    (box.tags || []).forEach(tag => {
      const s = document.createElement("span");
      s.className = "tag";
      s.textContent = tag;
      tagsWrap.appendChild(s);
    });

    c.appendChild(t);
    c.appendChild(note);
    if ((box.tags || []).length) c.appendChild(tagsWrap);

    a.appendChild(img);
    a.appendChild(c);

    a.dataset.search = [
      `box-${box.id}`,
      `box${box.id}`,
      `box ${box.id}`,
      `box-${parseInt(box.id,10)}`,
      box.note || "",
      (box.tags || []).join(" "),
    ].join(" ").toLowerCase();

    return a;
  }

  function render(list){
    grid.innerHTML = "";
    list.forEach(b => grid.appendChild(makeCard(b)));
    counter.textContent = `${list.length} boxes`;
    empty.style.display = list.length ? "none" : "block";
  }

  function applyFilter(){
    const term = normalize(q.value);
    const cards = Array.from(grid.querySelectorAll("a.card"));
    if (!term) {
      cards.forEach(c => c.style.display = "");
      counter.textContent = `${cards.length} boxes`;
      empty.style.display = "none";
      return;
    }
    let shown = 0;
    for (const card of cards){
      const ok = card.dataset.search.includes(term);
      card.style.display = ok ? "" : "none";
      if (ok) shown++;
    }
    counter.textContent = `${shown} / ${cards.length}`;
    empty.style.display = shown ? "none" : "block";
  }
  q.addEventListener("input", applyFilter);

  async function loadBoxes(){
    const res = await fetch("boxes.csv", { cache: "no-store" });
    if (!res.ok) throw new Error("boxes.csv not found");
    const text = await res.text();
    const { data } = parseCsv(text);

    // If boxes.csv has fewer lines, only those will show
    return data
      .filter(r => r.id && /^\d{1,2}$/.test(r.id.trim()) || /^\d{2}$/.test(r.id.trim()))
      .map(r => ({
        id: pad2(parseInt(r.id, 10)),
        url: (r.url || "").trim(),
        note: (r.note || ""),
        tags: splitTags(r.tags || ""),
        preview: (r.preview || "").trim()
      }))
      .sort((a,b) => parseInt(a.id,10) - parseInt(b.id,10));
  }

  (async () => {
    try {
      const boxes = await loadBoxes();
      render(boxes);
    } catch (e) {
      // fallback: show 50 empty
      const fallback = [];
      for (let i=1;i<=50;i++) fallback.push({ id: pad2(i), note:"", tags:[], preview:"" });
      render(fallback);
    }
  })();
</script>

</body>
</html>
